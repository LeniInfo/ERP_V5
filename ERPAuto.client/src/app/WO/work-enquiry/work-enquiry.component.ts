import { Component, OnInit, OnDestroy } from '@angular/core';
import { CommonModule, DecimalPipe } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { Router, ActivatedRoute } from '@angular/router';
import { ApiService, Customer } from '../../services/api.service';
import Swal from 'sweetalert2';

interface WorkMaster {
  fran?: string;
  workId: number;
  workType?: string;
  name: string;
  remarks?: string;
  unitPrice?: number;
  estimated?: number;
  [key: string]: any;
}

interface EnquiryItem {
  id: number;
  workId?: number;
  workName: string;
  price: number;
  quantity: number;
  total: number;
  descriptionEn: string;
  descriptionAr: string;
  descriptionArManuallyEdited?: boolean;
  lastAutoGeneratedAr?: string;
}

@Component({
  selector: 'app-work-enquiry',
  standalone: true,
  imports: [CommonModule, FormsModule, DecimalPipe],
  templateUrl: './work-enquiry.component.html',
  styleUrls: ['./work-enquiry.component.css']
})
export class WorkEnquiryComponent implements OnInit, OnDestroy {

  status: string = 'OPEN';
  enquiryDate: string = new Date().toISOString().split('T')[0];
  
  // Edit mode
  isEditMode: boolean = false;
  editRequestNo: string = '';
  
  // Customer
  customers: Customer[] = [];
  customerCode: string = '';
  customerSearchTerm: string = '';
  showCustomerDropdown: boolean = false;
  isLoadingCustomers: boolean = false;
  showCustomerModal: boolean = false;
  
  // Customer Form
  customerForm: Customer = this.getEmptyCustomer();
  emailError: string = '';
  phoneError: string = '';
  nameArManuallyEdited: boolean = false;
  
  // Enquiry Items
  enquiryItems: EnquiryItem[] = [];
  nextItemId: number = 1;
  
  // Header descriptions (stored at header level)
  headerDescriptionEn: string = '';
  headerDescriptionAr: string = '';
  
  // Grand Total
  grandTotal: number = 0;
  
  // WorkMaster
  workMasters: WorkMaster[] = [];
  isLoadingWorkMasters: boolean = false;
  
  // Default values
  readonly defaultFran: string = 'MAIN';
  readonly defaultBranch: string = 'MAIN';
  readonly defaultWarehouse: string = 'MAIN';
  readonly requestType: string = 'work order inquiry';
  
  private customerSearchTimeout: any = null;

  constructor(
    private router: Router,
    private route: ActivatedRoute,
    private apiService: ApiService
  ) { }

  ngOnInit(): void {
    this.loadCustomers();
    this.loadWorkMasters();
    
    // Initialize header descriptions
    this.headerDescriptionEn = '';
    this.headerDescriptionAr = '';
    
    // Check if we're in edit mode
    this.route.queryParams.subscribe(params => {
      if (params['requestNo']) {
        this.loadEnquiryForEdit(
          params['fran'] || this.defaultFran,
          params['branch'] || this.defaultBranch,
          params['warehouse'] || this.defaultWarehouse,
          params['requestType'] || this.requestType,
          params['requestNo']
        );
      } else {
        // New enquiry - clear descriptions
        this.headerDescriptionEn = '';
        this.headerDescriptionAr = '';
        this.addNewItem();
      }
    });
  }

  ngOnDestroy(): void {
    if (this.customerSearchTimeout) {
      clearTimeout(this.customerSearchTimeout);
    }
  }

  // ========== CUSTOMER FUNCTIONS ==========
  
  loadCustomers(): void {
    this.isLoadingCustomers = true;
    this.apiService.getAllCustomers().subscribe({
      next: (data) => {
        this.customers = data || [];
        this.isLoadingCustomers = false;
        console.log('Customers loaded:', this.customers.length);
      },
      error: (err) => {
        this.isLoadingCustomers = false;
        console.error('Error loading customers:', err);
        Swal.fire({
          icon: 'error',
          title: 'Error',
          text: 'Failed to load customers',
          confirmButtonColor: '#d33'
        });
      }
    });
  }

  searchCustomers(searchTerm: string): void {
    if (!searchTerm || searchTerm.trim().length < 1) {
      this.loadCustomers();
      return;
    }

    this.isLoadingCustomers = true;
    this.apiService.searchCustomers(searchTerm.trim()).subscribe({
      next: (data) => {
        this.customers = data || [];
        this.isLoadingCustomers = false;
      },
      error: (err) => {
        this.isLoadingCustomers = false;
        this.customers = [];
      }
    });
  }

  onCustomerSearch(event: any): void {
    const searchTerm = event.target.value;
    this.customerSearchTerm = searchTerm;
    this.showCustomerDropdown = searchTerm.trim().length >= 1;

    if (this.customerSearchTimeout) {
      clearTimeout(this.customerSearchTimeout);
    }

    if (searchTerm.trim().length >= 1) {
      this.customerSearchTimeout = setTimeout(() => {
        this.searchCustomers(searchTerm);
      }, 300);
    } else {
      this.loadCustomers();
    }
  }

  onCustomerInputFocus(): void {
    if (this.customerSearchTerm.trim().length >= 1 || this.customers.length > 0) {
      this.showCustomerDropdown = true;
    }
  }

  onCustomerInputBlur(): void {
    setTimeout(() => {
      this.showCustomerDropdown = false;
    }, 200);
  }

  selectCustomer(customer: Customer): void {
    this.customerCode = customer.customerCode;
    this.customerSearchTerm = this.getCustomerDisplayName(customer);
    this.showCustomerDropdown = false;
  }

  getCustomerDisplayName(customer: Customer): string {
    return customer.name || customer.customerCode || '';
  }

  getFilteredCustomers(): Customer[] {
    if (!this.customerSearchTerm || this.customerSearchTerm.trim().length < 1) {
      return this.customers.slice(0, 10);
    }
    const search = this.customerSearchTerm.toLowerCase().trim();
    return this.customers.filter(c => 
      c.customerCode?.toLowerCase().includes(search) ||
      c.name?.toLowerCase().includes(search) ||
      c.nameAr?.toLowerCase().includes(search) ||
      c.phone?.includes(search) ||
      c.email?.toLowerCase().includes(search)
    ).slice(0, 20);
  }

  getSelectedCustomerName(): string {
    const selectedCustomer = this.customers.find(c => c.customerCode === this.customerCode);
    return selectedCustomer ? this.getCustomerDisplayName(selectedCustomer) : '';
  }

  clearCustomerSelection(): void {
    this.customerCode = '';
    this.customerSearchTerm = '';
  }

  // ========== CUSTOMER MODAL FUNCTIONS ==========

  openCustomerModal(): void {
    this.customerForm = this.getEmptyCustomer();
    this.emailError = '';
    this.phoneError = '';
    this.nameArManuallyEdited = false;
    this.showCustomerModal = true;
  }

  closeCustomerModal(): void {
    this.showCustomerModal = false;
    this.customerForm = this.getEmptyCustomer();
    this.emailError = '';
    this.phoneError = '';
    this.nameArManuallyEdited = false;
  }

  saveCustomer(): void {
    if (!this.validateCustomerForm()) {
      return;
    }

    const customerName = this.customerForm.name;
    const customerEmail = this.customerForm.email;

    this.apiService.addCustomer(this.customerForm).subscribe({
      next: (response: any) => {
        Swal.fire({
          icon: 'success',
          title: 'Success!',
          text: response.message || 'Customer added successfully',
          confirmButtonColor: '#3085d6',
          timer: 1500
        });
        
        // Reset customer form
        this.customerForm = this.getEmptyCustomer();
        this.emailError = '';
        this.phoneError = '';
        this.nameArManuallyEdited = false;
        this.closeCustomerModal();
        
        // Reload customers and auto-select the new one
        this.loadCustomers();
        setTimeout(() => {
          // Try to find the customer by name and email (since code is auto-generated)
          const newCustomer = this.customers.find(c => 
            c.name === customerName && 
            (customerEmail ? c.email === customerEmail : true)
          );
          if (newCustomer) {
            this.customerCode = newCustomer.customerCode;
            this.customerSearchTerm = this.getCustomerDisplayName(newCustomer);
            this.showCustomerDropdown = false;
          } else if (response.customerCode) {
            // Fallback: use customerCode from response if available
            this.customerCode = response.customerCode;
            const foundCustomer = this.customers.find(c => c.customerCode === response.customerCode);
            if (foundCustomer) {
              this.customerSearchTerm = this.getCustomerDisplayName(foundCustomer);
            }
            this.showCustomerDropdown = false;
          }
        }, 500);
      },
      error: (err: any) => {
        Swal.fire({
          icon: 'error',
          title: 'Error',
          text: err.error?.message || err.message || 'Failed to add customer',
          confirmButtonColor: '#d33'
        });
      }
    });
  }

  getEmptyCustomer(): Customer {
    return {
      customerCode: '',
      name: '',
      nameAr: '',
      phone: '',
      email: '',
      address: '',
      vatNo: ''
    };
  }

  validateCustomerForm(): boolean {
    this.emailError = '';
    this.phoneError = '';

    if (!this.customerForm.name || this.customerForm.name.trim() === '') {
      Swal.fire({
        icon: 'error',
        title: 'Validation Error',
        text: 'Customer name is required',
        confirmButtonColor: '#d33'
      });
      return false;
    }

    if (this.customerForm.email && this.customerForm.email.trim() !== '') {
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      if (!emailRegex.test(this.customerForm.email)) {
        this.emailError = 'Invalid email format';
        return false;
      }
    }

    if (this.customerForm.phone && this.customerForm.phone.trim() !== '') {
      const phoneRegex = /^[0-9+\-\s()]+$/;
      if (!phoneRegex.test(this.customerForm.phone)) {
        this.phoneError = 'Invalid phone format';
        return false;
      }
    }

    return true;
  }

  onCustomerNameChange(value: string): void {
    if (!this.nameArManuallyEdited && value) {
      this.customerForm.nameAr = this.toArabic(value);
    }
  }

  onCustomerNameArFocus(): void {
    this.nameArManuallyEdited = true;
  }

  // ========== WORKMASTER FUNCTIONS ==========

  loadWorkMasters(): void {
    this.isLoadingWorkMasters = true;
    this.apiService.getAllWorkMasters().subscribe({
      next: (data) => {
        this.workMasters = data || [];
        this.isLoadingWorkMasters = false;
        console.log('WorkMasters loaded:', this.workMasters.length);
      },
      error: (err) => {
        this.isLoadingWorkMasters = false;
        console.error('Error loading WorkMasters:', err);
        Swal.fire({
          icon: 'error',
          title: 'Error',
          text: 'Failed to load Work Masters',
          confirmButtonColor: '#d33'
        });
      }
    });
  }

  onWorkSelected(item: EnquiryItem, workId: number): void {
    const selectedWork = this.workMasters.find(w => w.workId === workId);
    if (selectedWork) {
      item.workId = selectedWork.workId;
      item.workName = selectedWork.name;
      // Price is editable, so don't auto-load
      // Recalculate when work is selected
      this.calculateItemTotal(item);
    }
  }

  getWorkDisplayName(work: WorkMaster): string {
    return work.name || `Work ID: ${work.workId}`;
  }

  // ========== ENQUIRY ITEMS FUNCTIONS ==========

  addNewItem(): void {
    this.enquiryItems.push({
      id: this.nextItemId++,
      workId: undefined,
      workName: '',
      price: 0,
      quantity: 0,
      total: 0,
      descriptionEn: '',
      descriptionAr: '',
      descriptionArManuallyEdited: false,
      lastAutoGeneratedAr: ''
    });
  }

  removeItem(item: EnquiryItem): void {
    const index = this.enquiryItems.indexOf(item);
    if (index > -1) {
      this.enquiryItems.splice(index, 1);
      this.calculateGrandTotal();
    }
  }

  calculateItemTotal(item: EnquiryItem): void {
    const price = item.price || 0;
    const quantity = item.quantity || 0;
    
    // Calculate total (Price * Quantity)
    item.total = price * quantity;
    
    this.calculateGrandTotal();
  }

  calculateGrandTotal(): void {
    this.grandTotal = this.enquiryItems.reduce((sum, item) => sum + (item.total || 0), 0);
  }

  // Auto-fill Arabic description when English description is entered
  onDescriptionEnBlur(item: EnquiryItem): void {
    // Always update Arabic when leaving English field if it hasn't been manually edited
    if (item.descriptionEn && item.descriptionEn.trim()) {
      const autoGeneratedAr = this.toArabic(item.descriptionEn);
      // Truncate to 300 characters
      const truncatedAr = autoGeneratedAr.length > 300 ? autoGeneratedAr.substring(0, 300) : autoGeneratedAr;
      // Update if not manually edited, or if current Arabic matches the auto-generated value (meaning it was auto-generated)
      if (!item.descriptionArManuallyEdited || item.descriptionAr === truncatedAr || item.descriptionAr === item.lastAutoGeneratedAr) {
        item.descriptionAr = truncatedAr;
        item.lastAutoGeneratedAr = truncatedAr;
        item.descriptionArManuallyEdited = false; // Reset flag since we're auto-updating
      }
    } else {
      // Clear Arabic if English is empty (only if not manually edited)
      if (!item.descriptionArManuallyEdited) {
        item.descriptionAr = '';
        item.lastAutoGeneratedAr = '';
      }
    }
  }

  // Track when Arabic description is manually edited
  onDescriptionArChange(item: EnquiryItem): void {
    // Check if the current Arabic value matches what would be auto-generated from current English
    if (item.descriptionEn && item.descriptionEn.trim()) {
      const autoGeneratedAr = this.toArabic(item.descriptionEn);
      // If Arabic matches auto-generated value, it's not manually edited
      if (item.descriptionAr === autoGeneratedAr) {
        item.descriptionArManuallyEdited = false;
        item.lastAutoGeneratedAr = autoGeneratedAr;
      } else {
        // If Arabic differs from auto-generated, it's manually edited
        item.descriptionArManuallyEdited = true;
      }
    } else {
      // If English is empty but Arabic has content, it's manually edited
      if (item.descriptionAr && item.descriptionAr.trim()) {
        item.descriptionArManuallyEdited = true;
      } else {
        item.descriptionArManuallyEdited = false;
      }
    }
  }

  // Also update Arabic when English changes (if not manually edited)
  onDescriptionEnChange(item: EnquiryItem): void {
    // Truncate to 300 characters
    if (item.descriptionEn && item.descriptionEn.length > 300) {
      item.descriptionEn = item.descriptionEn.substring(0, 300);
    }
    
    // Only auto-update if Arabic hasn't been manually edited
    if (item.descriptionEn && item.descriptionEn.trim()) {
      const autoGeneratedAr = this.toArabic(item.descriptionEn);
      // Truncate auto-generated Arabic to 300 characters
      const truncatedAr = autoGeneratedAr.length > 300 ? autoGeneratedAr.substring(0, 300) : autoGeneratedAr;
      // Update if not manually edited, or if current Arabic matches last auto-generated
      if (!item.descriptionArManuallyEdited || item.descriptionAr === item.lastAutoGeneratedAr) {
        item.descriptionAr = truncatedAr;
        item.lastAutoGeneratedAr = truncatedAr;
        item.descriptionArManuallyEdited = false;
      }
    } else {
      // Clear Arabic if English is empty (only if not manually edited)
      if (!item.descriptionArManuallyEdited) {
        item.descriptionAr = '';
        item.lastAutoGeneratedAr = '';
      }
    }
  }

  // Limit input to 300 characters for English description
  onDescriptionEnInput(item: EnquiryItem, event: any): void {
    const value = event.target.value;
    if (value && value.length > 300) {
      item.descriptionEn = value.substring(0, 300);
      // Update the textarea value to prevent further input
      event.target.value = item.descriptionEn;
      event.target.setSelectionRange(300, 300); // Move cursor to end
    }
  }

  // Limit input to 300 characters for Arabic description
  onDescriptionArInput(item: EnquiryItem, event: any): void {
    const value = event.target.value;
    if (value && value.length > 300) {
      item.descriptionAr = value.substring(0, 300);
      // Update the textarea value to prevent further input
      event.target.value = item.descriptionAr;
      event.target.setSelectionRange(300, 300); // Move cursor to end
    }
  }

  // Convert English text to Arabic (simple transliteration)
  toArabic(text: string): string {
    const map: { [key: string]: string } = {
      'a': 'ا', 'b': 'ب', 'c': 'ك', 'd': 'د', 'e': 'ي',
      'f': 'ف', 'g': 'ج', 'h': 'ه', 'i': 'ي', 'j': 'ج',
      'k': 'ك', 'l': 'ل', 'm': 'م', 'n': 'ن', 'o': 'و',
      'p': 'ب', 'q': 'ق', 'r': 'ر', 's': 'س', 't': 'ت',
      'u': 'و', 'v': 'ف', 'w': 'و', 'x': 'كس', 'y': 'ي', 'z': 'ز',
      ' ': ' ', '0': '٠', '1': '١', '2': '٢', '3': '٣', '4': '٤',
      '5': '٥', '6': '٦', '7': '٧', '8': '٨', '9': '٩'
    };

    return text
      .toLowerCase()
      .split('')
      .map(c => map[c] || c)
      .join('');
  }

  // Navigate back to work enquiry list
  goBackToList(): void {
    this.router.navigate(['./work-enquiry-list']);
  }

  // ========== SAVE WORK ENQUIRY FUNCTIONS ==========

  saveWorkEnquiry(): void {
    // Validate required fields
    if (!this.customerCode || this.customerCode.trim() === '') {
      Swal.fire({
        icon: 'error',
        title: 'Validation Error',
        text: 'Please select a customer',
        confirmButtonColor: '#d33'
      });
      return;
    }

    // Validate items
    const validItems = this.enquiryItems.filter(item => 
      item.workId && item.workId > 0 && item.price >= 0 && item.quantity > 0
    );

    if (validItems.length === 0) {
      Swal.fire({
        icon: 'error',
        title: 'Validation Error',
        text: 'Please add at least one valid work item with work, price, and quantity',
        confirmButtonColor: '#d33'
      });
      return;
    }

    // Validate descriptions - at least one description (English or Arabic) is required
    const hasDescriptionEn = validItems.some(item => item.descriptionEn && item.descriptionEn.trim().length > 0);
    const hasDescriptionAr = validItems.some(item => item.descriptionAr && item.descriptionAr.trim().length > 0);
    
    if (!hasDescriptionEn && !hasDescriptionAr) {
      Swal.fire({
        icon: 'error',
        title: 'Validation Error',
        text: 'Please provide at least one description (English or Arabic) for the work items',
        confirmButtonColor: '#d33'
      });
      return;
    }

    // Show loading
    Swal.fire({
      title: 'Saving...',
      text: 'Please wait while we save your work enquiry',
      allowOutsideClick: false,
      didOpen: () => {
        Swal.showLoading();
      }
    });

    // Get next request number only if not in edit mode
    if (this.isEditMode && this.editRequestNo) {
      this.proceedWithSave(this.editRequestNo, validItems);
    } else {
      this.apiService.getNextRequestNumber().subscribe({
        next: (response) => {
          let requestNo: string;
          if (typeof response === 'string') {
            requestNo = response;
          } else if (response && typeof response === 'object') {
            requestNo = (response as any).value || (response as any).data || (response as any).result || String(response);
          } else {
            requestNo = String(response);
          }
          requestNo = requestNo.replace(/^["']|["']$/g, '').trim(); // Remove any quotes
          
          if (!requestNo || requestNo.length === 0) {
            Swal.close();
            Swal.fire({
              icon: 'error',
              title: 'Error',
              text: 'Empty request number received from server',
              confirmButtonColor: '#d33'
            });
            return;
          }
          
          console.log('Generated request number:', requestNo);
          this.proceedWithSave(requestNo, validItems);
        },
        error: (err) => {
          Swal.close();
          console.error('Error getting request number:', err);
          console.error('Error details:', {
            status: err.status,
            statusText: err.statusText,
            error: err.error
          });
          
          let errorMessage = 'Failed to generate request number';
          if (err.error?.message) {
            errorMessage = err.error.message;
          } else if (err.error?.text) {
            errorMessage = err.error.text;
          } else if (err.message) {
            errorMessage = err.message;
          } else if (err.status === 0) {
            errorMessage = 'Cannot connect to server. Please check if the API server is running.';
          } else if (err.status === 404) {
            errorMessage = 'API endpoint not found. Please check the server configuration.';
          } else if (err.status === 500) {
            errorMessage = 'Server error. Please check server logs for details.';
          }
          
          Swal.fire({
            icon: 'error',
            title: 'Error',
            text: errorMessage,
            confirmButtonColor: '#d33',
            footer: err.status ? `Status: ${err.status}` : ''
          });
        }
      });
    }
  }

  loadEnquiryForEdit(fran: string, branch: string, warehouse: string, requestType: string, requestNo: string): void {
    this.isEditMode = true;
    this.editRequestNo = requestNo;
    
    // Load header
    this.apiService.getRequestHeaderByKey(fran, branch, warehouse, requestType, requestNo).subscribe({
      next: (header) => {
        this.customerCode = header.customer || '';
        this.enquiryDate = header.requestDate ? new Date(header.requestDate).toISOString().split('T')[0] : new Date().toISOString().split('T')[0];
        this.status = header.status || 'OPEN';
        
        // Load descriptions from header
        this.headerDescriptionEn = header.descEn || '';
        this.headerDescriptionAr = header.descArabic || '';
        
        // Set customer search term
        const customer = this.customers.find(c => c.customerCode === this.customerCode);
        if (customer) {
          this.customerSearchTerm = this.getCustomerDisplayName(customer);
        }
        
        // Load details
        this.loadEnquiryDetailsForEdit(fran, branch, warehouse, requestType, requestNo);
      },
      error: (err) => {
        console.error('Error loading enquiry header:', err);
        Swal.fire({
          icon: 'error',
          title: 'Error',
          text: 'Failed to load work enquiry',
          confirmButtonColor: '#d33'
        });
        this.goBackToList();
      }
    });
  }

  loadEnquiryDetailsForEdit(fran: string, branch: string, warehouse: string, requestType: string, requestNo: string): void {
    this.apiService.getRequestDetailsByHeader(fran, branch, warehouse, requestType, requestNo).subscribe({
      next: (details) => {
        this.enquiryItems = [];
        this.nextItemId = 1;

        // Parse header descriptions and split by ' | ' to distribute to items
        const headerDescEn = this.headerDescriptionEn || '';
        const headerDescAr = this.headerDescriptionAr || '';
        const descEnParts = headerDescEn.split(' | ').filter(d => d.trim().length > 0);
        const descArParts = headerDescAr.split(' | ').filter(d => d.trim().length > 0);

        details.forEach((detail, index) => {
          // PART contains the workId as string, parse it
          let workId: number | undefined = undefined;
          
          if (detail.part) {
            const parsed = parseInt(detail.part, 10);
            if (!isNaN(parsed)) {
              workId = parsed;
            }
          }
          
          // Fallback to workId if part parsing fails
          if (!workId && detail.workId) {
            if (typeof detail.workId === 'number') {
              workId = detail.workId;
            } else {
              const parsed = parseInt(String(detail.workId), 10);
              workId = !isNaN(parsed) ? parsed : undefined;
            }
          }
          
          // Find work master to get name
          const workMaster = workId ? this.workMasters.find(w => w.workId === workId) : null;
          
          // Get description for this item - only assign if there are multiple descriptions or it's the first item
          // If only one description exists, assign it only to the first item
          let itemDescEn = '';
          let itemDescAr = '';
          
          if (descEnParts.length > 0) {
            // If multiple descriptions, distribute by index; if single, only to first item
            if (descEnParts.length > 1 && index < descEnParts.length) {
              itemDescEn = descEnParts[index];
            } else if (descEnParts.length === 1 && index === 0) {
              itemDescEn = descEnParts[0];
            }
          }
          
          if (descArParts.length > 0) {
            // If multiple descriptions, distribute by index; if single, only to first item
            if (descArParts.length > 1 && index < descArParts.length) {
              itemDescAr = descArParts[index];
            } else if (descArParts.length === 1 && index === 0) {
              itemDescAr = descArParts[0];
            }
          }
          
          // Check if Arabic was manually edited (different from auto-generated)
          const autoGeneratedAr = itemDescEn ? this.toArabic(itemDescEn) : '';
          const isManuallyEdited = itemDescAr.length > 0 && itemDescAr !== autoGeneratedAr;
          
          const item: EnquiryItem = {
            id: this.nextItemId++,
            workId: workId,
            workName: workMaster ? workMaster.name : (workId ? `Work ID: ${workId}` : ''),
            price: detail.unitPrice || 0,
            quantity: detail.qty || 0,
            total: detail.totalValue || 0,
            descriptionEn: itemDescEn,
            descriptionAr: itemDescAr,
            descriptionArManuallyEdited: isManuallyEdited,
            lastAutoGeneratedAr: autoGeneratedAr
          };
          
          this.enquiryItems.push(item);
        });

        // Recalculate totals
        this.calculateGrandTotal();

        if (this.enquiryItems.length === 0) {
          this.addNewItem();
        }
      },
      error: (err) => {
        console.error('Error loading enquiry details:', err);
        this.addNewItem();
      }
    });
  }

  private proceedWithSave(requestNo: string, validItems: EnquiryItem[]): void {
    // Parse enquiry date
    const enquiryDate = new Date(this.enquiryDate);
    const requestDate = enquiryDate.toISOString().split('T')[0];

    // Combine descriptions from all items (each item description is already limited to 300 chars)
    let allDescriptionsEn = validItems
      .map(item => {
        const desc = (item.descriptionEn?.trim() || '').substring(0, 300);
        return desc;
      })
      .filter(desc => desc.length > 0)
      .join(' | ');
    
    let allDescriptionsAr = validItems
      .map(item => {
        const desc = (item.descriptionAr?.trim() || '').substring(0, 300);
        return desc;
      })
      .filter(desc => desc.length > 0)
      .join(' | ');
    
    // Truncate combined descriptions to max 300 characters for DESCEN and DESARABIC
    if (allDescriptionsEn.length > 300) {
      allDescriptionsEn = allDescriptionsEn.substring(0, 300);
    }
    if (allDescriptionsAr.length > 300) {
      allDescriptionsAr = allDescriptionsAr.substring(0, 300);
    }

    // Prepare header data
    const headerData: any = {
      fran: this.defaultFran,
      branch: this.defaultBranch,
      warehouse: this.defaultWarehouse,
      requestType: this.requestType,
      requestNo: requestNo,
      requestDate: requestDate,
      customer: this.customerCode,
      requestSource: 'inquiry',
      refNo: '0',
      refDate: requestDate,
      seqNo: 0,
      seqPrefix: 'inquiry',
      currency: 'USD',
      noOfItems: validItems.length,
      discount: 0,
      vatValue: 0,
      totalValue: this.grandTotal || 0,
      descEn: allDescriptionsEn,
      descArabic: allDescriptionsAr,
      createDt: requestDate,
      createTm: new Date().toISOString(),
      createBy: 'SYSTEM',
      createRemarks: 'Work Enquiry created',
      updateDt: requestDate,
      updateTm: new Date().toISOString(),
      updateBy: 'SYSTEM',
      updateRemarks: ''
    };

    if (this.isEditMode && this.editRequestNo) {
      // Update existing enquiry - use editRequestNo instead of newly generated one
      headerData.requestNo = this.editRequestNo;
      this.apiService.updateRequestHeader(this.defaultFran, this.defaultBranch, this.defaultWarehouse, this.requestType, this.editRequestNo, headerData).subscribe({
        next: (response: any) => {
          console.log('Request header updated:', response);
          // Delete old details and save new ones
          this.deleteOldDetailsAndSaveNew(this.editRequestNo, requestDate, validItems);
        },
        error: (err) => {
          Swal.close();
          console.error('Error updating request header:', err);
          Swal.fire({
            icon: 'error',
            title: 'Error',
            text: err.error?.message || 'Failed to update work enquiry header',
            confirmButtonColor: '#d33'
          });
        }
      });
    } else {
      // Create new enquiry
      this.apiService.createRequestHeader(headerData).subscribe({
        next: (headerResponse: any) => {
          console.log('Request header created:', headerResponse);
          // After header is saved, save all detail items
          this.saveRequestDetails(requestNo, requestDate, validItems);
        },
        error: (err) => {
          Swal.close();
          console.error('Error creating request header:', err);
          Swal.fire({
            icon: 'error',
            title: 'Error',
            text: err.error?.message || 'Failed to create work enquiry header',
            confirmButtonColor: '#d33'
          });
        }
      });
    }
  }

  private saveRequestDetails(requestNo: string, requestDate: string, validItems: EnquiryItem[]): void {
    let completedItems = 0;
    let hasError = false;
    const totalItems = validItems.length;

    if (totalItems === 0) {
      Swal.close();
      Swal.fire({
        icon: 'success',
        title: 'Success!',
        text: `Work Enquiry ${requestNo} created successfully`,
        confirmButtonColor: '#3085d6',
        timer: 2000
      });
      this.goBackToList();
      return;
    }

    validItems.forEach((item, index) => {
      // REQUESTDT - selected date
      // MAKE - Always from work-enquiry (workName), IF VALUE HAVE VALUES ELSE "no"
      // Truncate to 10 characters to match current database column size
      // TODO: After running UpdateRequestDetailMakeColumn.sql to update DB to 50 chars, change this to 50
      const makeValue = item.workName && item.workName.trim() 
        ? item.workName.trim().substring(0, 10) 
        : 'no';
      // PART - SELECTED LINE ITEM ID (workId as string)
      const partValue = item.workId ? item.workId.toString() : '';
      // QTY - IF VALUE HAVE VALUES ELSE 0
      const qtyValue = item.quantity && item.quantity > 0 ? item.quantity : 0;
      // UNITPRICE - IF VALUE HAVE VALUES ELSE 0
      const unitPriceValue = item.price && item.price > 0 ? item.price : 0;
      // TOTALVALUE - IF VALUE HAVE VALUES ELSE 0
      const totalValue = item.total && item.total > 0 ? item.total : 0;

      const detailData: any = {
        fran: this.defaultFran,
        branch: this.defaultBranch,
        warehouse: this.defaultWarehouse,
        requestType: this.requestType,
        requestNo: requestNo,
        requestSrl: (index + 1).toString().padStart(3, '0'),
        requestDate: requestDate,
        workId: item.workId || 0,
        make: makeValue,
        part: partValue,
        qty: qtyValue,
        unitPrice: unitPriceValue,
        discount: 0,
        vatPercentage: 0,
        vatValue: 0,
        discountValue: 0,
        totalValue: totalValue,
        createDt: requestDate,
        createTm: new Date().toISOString(),
        createBy: 'SYSTEM',
        createRemarks: `Item: ${item.workName || 'N/A'}`,
        updateDt: requestDate,
        updateTm: new Date().toISOString(),
        updateBy: 'SYSTEM',
        updateRemarks: ''
      };

      this.apiService.createRequestDetail(detailData).subscribe({
        next: () => {
          completedItems++;
          console.log(`Request detail ${index + 1} created`);

          // If all items are created, show success
          if (completedItems === totalItems && !hasError) {
            Swal.close();
            Swal.fire({
              icon: 'success',
              title: 'Success!',
              text: `Work Enquiry ${requestNo} ${this.isEditMode ? 'updated' : 'created'} successfully with ${totalItems} items`,
              confirmButtonColor: '#3085d6',
              timer: 2000
            });
            // Navigate back to list
            setTimeout(() => {
              this.goBackToList();
            }, 2000);
          }
        },
        error: (err) => {
          hasError = true;
          Swal.close();
          console.error(`Error creating request detail ${index + 1}:`, err);
          Swal.fire({
            icon: 'error',
            title: 'Partial Success',
            text: `Work Enquiry header created but failed to create item ${index + 1}. Please check and retry.`,
            confirmButtonColor: '#d33'
          });
        }
      });
    });
  }

  private deleteOldDetailsAndSaveNew(requestNo: string, requestDate: string, validItems: EnquiryItem[]): void {
    // First, get existing details to delete them
    this.apiService.getRequestDetailsByHeader(this.defaultFran, this.defaultBranch, this.defaultWarehouse, this.requestType, requestNo).subscribe({
      next: (existingDetails) => {
        let deletedCount = 0;
        const totalDetails = existingDetails.length;

        if (totalDetails === 0) {
          // No existing details, just save new ones
          this.saveRequestDetails(requestNo, requestDate, validItems);
          return;
        }

        // Delete all existing details
        existingDetails.forEach((detail: any) => {
          this.apiService.deleteRequestDetail(detail.fran, detail.branch, detail.warehouse, detail.requestType, detail.requestNo, detail.requestSrl).subscribe({
            next: () => {
              deletedCount++;
              if (deletedCount === totalDetails) {
                // All deleted, now save new ones
                this.saveRequestDetails(requestNo, requestDate, validItems);
              }
            },
            error: (err: any) => {
              console.error(`Error deleting detail ${detail.requestSrl}:`, err);
              deletedCount++;
              if (deletedCount === totalDetails) {
                // Continue even if some deletions failed
                this.saveRequestDetails(requestNo, requestDate, validItems);
              }
            }
          });
        });
      },
      error: (err) => {
        console.error('Error loading existing details for deletion:', err);
        // Continue to save new details anyway
        this.saveRequestDetails(requestNo, requestDate, validItems);
      }
    });
  }
}
